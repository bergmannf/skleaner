/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.suse.skleaner

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.arguments.optional
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.option
import org.openstack4j.api.OSClient
import org.openstack4j.model.common.ActionResponse
import org.openstack4j.model.common.Identifier
import org.openstack4j.model.compute.SecGroupExtension
import org.openstack4j.model.compute.Server
import org.openstack4j.model.network.Network
import org.openstack4j.model.network.Port
import org.openstack4j.model.network.Router
import org.openstack4j.model.network.Subnet
import org.openstack4j.model.network.ext.HealthMonitorV2
import org.openstack4j.model.network.ext.LbPoolV2
import org.openstack4j.model.network.ext.ListenerV2
import org.openstack4j.model.network.ext.LoadBalancerV2
import org.openstack4j.openstack.OSFactory

data class Configuration(val authUrl: String, val username: String, val password: String, val project: String, val domain: String) {
    companion object {
        fun fromEnvironment(): Configuration {
            val authUrl = System.getenv("OS_AUTH_URL")
            val username = System.getenv("OS_USERNAME")
            val password = System.getenv("OS_PASSWORD")
            val project = System.getenv("OS_PROJECT_ID")
            val domain = System.getenv("OS_USER_DOMAIN_NAME")
            return Configuration(authUrl, username, password, project, domain)
        }
    }
}


class OpenstackObjects(private val api: OSClient.OSClientV3, private val verboseOutput: Boolean) {
    private lateinit var securityGroups: List<SecGroupExtension>
    private lateinit var machines: List<Server>
    private lateinit var routers: List<Router>
    private lateinit var healthMonitors: List<HealthMonitorV2>
    private lateinit var pools: List<LbPoolV2>
    private lateinit var networks: List<Network>
    private lateinit var loadBalancers: List<LoadBalancerV2>
    private lateinit var ports: List<Port>
    private lateinit var subnets: List<Subnet>
    private lateinit var listeners: List<ListenerV2>

    fun collectData(stackName: String, internalNetwork: String, internalRouter: String?) {
        println("${Cli.blue}Gathering  Data${Cli.reset}")
        this.networks = this.api.networking().network().list().filter { it.name.contains(internalNetwork) }
        log("${Cli.red}Networks${Cli.reset}: $networks")
        this.loadBalancers = this.api.networking().lbaasV2().loadbalancer().list().filter { it.name.contains(stackName) }
        log("${Cli.red}Loadbalancers${Cli.reset}: $loadBalancers")
        this.ports = findPorts()
        log("${Cli.red}Ports${Cli.reset}: $ports")
        this.subnets = findSubnets()
        log("${Cli.red}Subnets${Cli.reset}: $subnets")
        this.listeners = findListeners()
        log("${Cli.red}Listeners${Cli.reset}: $listeners")
        this.pools = findPools()
        log("${Cli.red}Pools${Cli.reset}: $pools")
        this.healthMonitors = findHealthMonitors()
        log("${Cli.red}HealthMonitors${Cli.reset}: $healthMonitors")
        this.machines = this.api.compute().servers().list().filter { it.name.contains(stackName) }
        log("${Cli.red}Machines${Cli.reset}: $machines")
        this.securityGroups = findSecurityGroups()
        log("${Cli.red}SecurityGroups${Cli.reset}: $securityGroups")
        if (!internalRouter.isNullOrBlank()) {
            this.routers = this.api.networking().router().list().filter { it.name.contains(internalRouter) }
            log("${Cli.red}Routers${Cli.reset}: $routers")
        }
    }

    private fun findSecurityGroups(): List<SecGroupExtension> {
        var securityGroups = mutableListOf<SecGroupExtension>()
        for (machine in this.machines) {
            val sgs = this.api.compute().securityGroups().listServerGroups(machine.id)
            securityGroups.addAll(sgs)
        }
        return securityGroups.toList()
    }

    fun transform() {
        println("${Cli.blue}Modifying Data${Cli.reset}")
        for (it in ports) {
            if (it.deviceOwner == "network:router_interface") {
                log("Resetting port owner of ${Cli.yellow}'network:router_interface'${Cli.reset}")
                this.api.networking().port().update(it.toBuilder().deviceOwner("null_owner").build())
            } else if (it.deviceOwner == "neutron:LOADBALANCERV2") {
                log("Resetting port owner of ${Cli.yellow}'neutron:LOADBALANCERV2'${Cli.reset}")
                this.api.networking().port().update(it.toBuilder().deviceOwner("null_owner").build())
            }
        }
        this.ports = this.findPorts()
    }

    fun remove() {
        println("${Cli.blue}Starting Removal${Cli.reset}")
        log("Removing machines")
        this.machines.forEach {
            log("Removing machine: $it")
            checkedRemoval { this.api.compute().servers().delete(it.id) }
        }
        log("Removing security groups")
        this.securityGroups.forEach {
            log("Removing security group: $it")
            checkedRemoval { this.api.compute().securityGroups().delete(it.id) }
        }
        log("Removing HealthMonitor")
        this.healthMonitors.forEach {
            log("Removing healthmonitor: $it")
            checkedRemoval { this.api.networking().lbaasV2().healthMonitor().delete(it.id) }
        }
        log("Removing Pools")
        this.pools.forEach {
            log("Removing pool: $it")
            checkedRemoval { this.api.networking().lbaasV2().lbPool().delete(it.id) }
        }
        log("Removing Subnets")
        this.subnets.forEach {
            log("Removing subnet: $it")
            checkedRemoval { this.api.networking().subnet().delete(it.id) }
        }
        log("Removing Ports")
        this.ports.forEach {
            log("Removing port: $it")
            checkedRemoval { this.api.networking().port().delete(it.id) }
        }
        log("Removing Listeners")
        this.listeners.forEach {
            log("Removing listener: $it")
            checkedRemoval { this.api.networking().lbaasV2().listener().delete(it.id) }
        }
        log("Removing Loadbalancers")
        this.loadBalancers.forEach {
            log("Removing loadbalancer: $it")
            checkedRemoval { this.api.networking().lbaasV2().loadbalancer().delete(it.id) }
        }
        log("Removing Networks")
        this.networks.forEach {
            log("Removing network: $it")
            checkedRemoval { this.api.networking().network().delete(it.id) }
        }
        log("Removing Routers")
        this.routers.forEach {
            log("Removing router: $it")
            checkedRemoval { this.api.networking().router().delete(it.id) }
        }
    }

    private fun findPorts(): List<Port> {
        val ports = mutableListOf<Port>()
        for (network in this.networks) {
            val ps = this.api.networking().port().list().filter { it.networkId.equals(network.id) }
            ports.addAll(ps)
        }
        return ports
    }

    private fun findSubnets(): List<Subnet> {
        val subnets = mutableListOf<Subnet>()
        for (network in this.networks) {
            val sns = network.neutronSubnets
            subnets.addAll(sns)
        }
        return subnets
    }

    private fun findHealthMonitors(): List<HealthMonitorV2> {
        val healthMonitors = mutableListOf<HealthMonitorV2>()
        for (pool in this.pools) {
            val hms = this.api.networking().lbaasV2().healthMonitor().list().filter {
                var result = false
                for (hmPool in it.pools) {
                    if (pool.id == hmPool.id) {
                        result = true
                        break
                    }
                }
                result
            }
            healthMonitors.addAll(hms)
        }
        return healthMonitors.toList()
    }

    private fun findListeners(): List<ListenerV2> {
        val listeners = mutableListOf<ListenerV2>()
        for (loadBalancer in this.loadBalancers) {
            val ls = loadBalancer.listeners
            listeners.addAll(ls.map {
                this.api.networking().lbaasV2().listener().get(it.id)
            })
        }
        return listeners
    }

    private fun findPools(): List<LbPoolV2> {
        val pools = mutableListOf<LbPoolV2>()
        for (listener in this.listeners) {
            val ps = this.api.networking().lbaasV2().lbPool().list().filter {
                var result = false
                // It seems that the pool objects do not compare via `equals`, so
                // it.listeners.contains(listener) won't work
                for (poolListener in it.listeners) {
                    if (listener.id == poolListener.id) {
                        result = true
                        break
                    }
                }
                result
            }
            pools.addAll(ps)
        }
        return pools.toList()
    }

    private fun checkedRemoval(removalFunction: () -> ActionResponse) {
        val resp = removalFunction()
        if (!resp.isSuccess) {
            println("${Cli.red}Error during removal: ${resp.fault}${Cli.reset}")
        }
    }

    private fun log(message: String) {
        if (verboseOutput) println(message)
    }
}


object Cli {
    val escape = "\u001B"
    val red = "$escape[0;31m"
    val green = "$escape[0;32m"
    val yellow = "$escape[0;33m"
    val blue = "$escape[0;34m"
    val magenta = "$escape[0;35m"
    val cyan = "$escape[0;36m"
    val white = "$escape[0;37m"
    val reset = "$escape[0;37m"
}


class Skleaner : CliktCommand() {
    val internalNet: String by argument(help = "value of the internal_net parameter")
    val stackName: String by argument(help = "value of the stack_name parameter")
    val internalRouter: String? by argument(help = "value of the internal_router parameter").optional()
    val dryRun: Boolean by option("--dry-run", "-d", help = "do not actually remove found objects").flag(default = false)
    val verbose: Boolean by option("--verbose", "-V", help = "Verbose output").flag(default = false)

    override fun run() {
        val config = Configuration.fromEnvironment()
        val os = OSFactory.builderV3()
                .endpoint(config.authUrl)
                .credentials(config.username, config.password, Identifier.byName(config.domain))
                .scopeToProject(Identifier.byId(config.project))
                .authenticate()

        val data = OpenstackObjects(os, verbose)
        data.collectData(this.stackName, this.internalNet, this.internalRouter)
        if (!this.dryRun) {
            data.transform()
            data.remove()
        } else {
            println("${Cli.yellow}DRY RUN: Did not change openstack${Cli.reset}")
        }
    }
}


fun main(args: Array<String>) {
    val s = Skleaner().main(args)
}

